/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>
 *
 * &copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.
 *
 * </center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <gb_gpio.h>
#include <gb_rcc.h>
#include <GB_UART.h>
#include <gb_t_delay.h>
#include "GB_adc.h"

#include "stm32f1xx.h"
/*
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/


#define DEMCR        			*((volatile uint32_t*) 0xE000EDFCU )

/* ITM register addresses */
#define ITM_STIMULUS_PORT0   	*((volatile uint32_t*) 0xE0000000 )
#define ITM_TRACE_EN          	*((volatile uint32_t*) 0xE0000E00 )


int _write(int file, char *ptr, int len)
{
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
	{
		//__io_putchar(*ptr++);
		 ITM_SendChar(*ptr++);
	}
	return len;
}

uint32_t RxData[3];
uint16_t adc;
int main(void)
{
	system_clk();
	timer_initialise();
	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;
	AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_JTAGDISABLE;
	//Gpio_output_pushpull_conf();

	GB_uart_init1();
	//adc_init();
	adc_init_multichannel();
	dma_init();

	//dma_adc_convert((uint32_t ) &ADC1->DR, (uint16_t) RxData, 3);

	GB_printString1("ADC Driver");

while(1)
{

//	adc = adc_convertPOL_START();
//	GB_decimel1(adc);
//	delay_ms(1000);
//	GB_printString1("\n");

	dma_adc_convert((uint32_t ) &ADC1->DR, (uint32_t) &RxData, 3);



//
//	if((DMA1->ISR & DMA_ISR_TCIF1))
//
//	DMA1->IFCR |= DMA_IFCR_CTCIF1;

//	ADC1->CR2|= ADC_CR2_ADON; //ADC Enabled, before enabling should check that adc is disabled.
//
//		//delay_us(2); // wait for 2 us
//	//	dma_for_adc(srcadd,destadd,datasize);   // initilise dma for adc1
//	 ADC1->CR2 |= ADC_CR2_DMA; //ENABLE THE DMA
//
//	    DMA1_Channel1->CCR &= ~DMA_CCR_EN; // DIABLE THE DMA CHANNEL 1 BEFORE CONFIGURING IT
//
//	    DMA1_Channel1->CNDTR = 3; // No of data bytes to be transfered
//
//	    DMA1_Channel1->CPAR = (uint32_t ) &ADC1->DR;
//
//	    DMA1_Channel1->CMAR =  (uint32_t) &RxData;
//
//	    //DMA1_Channel1->CCR |= DMA_CCR_TCIE | DMA_CCR_HTIE; // full transfer and transfer interrupt enabled
//
////		__NVIC_EnableIRQ(DMA1_Channel1_IRQn);
////		__NVIC_SetPriority (DMA1_Channel1_IRQn, 0);
//
//	    DMA1_Channel1->CCR |= DMA_CCR_EN; //enable the dma
//		//start the adc
//		//ADC1->SR &= ~ADC_SR_EOC; //Clear regular group conversion flag  (To ensure of no unknown state from potential previous ADC operations) */
//		 ADC1->CR2|= ADC_CR2_EXTTRIG; // externel event trigger for conversion is enabled , always enabled
//		 ADC1->CR2|= ADC_CR2_SWSTART; // Start ADC Conversion of regular group
//


}
}
