/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include <stdio.h>


//#include "default.h"
#include "rcc.h"
#include "t_delay.h"
#include "gpio.h"

#include "GB_uart.h"



#include "stm32f1xx.h"
char d;

	#define gb_RX_BUFFER_SIZE_UART2 255
	uint8_t gb_Rx_Buffer_UART2[gb_RX_BUFFER_SIZE_UART2]; // character array (buffer)
	uint8_t gb_RX_Wr_Index_UART2 =0; //index of next char to be put into the buffer  // head
	uint8_t gb_RX_Rd_Index_UART2=0; //index of next char to be fetched from the buffer    //tail
	uint8_t gb_RX_Counter_UART2=0; //a total count of characters in the buffer
	uint8_t gb_RX_No_of_byte_UART2=0;
	_Bool gb_RX_Buffer_Overflow_UART2; // This flag is set on USART Receiver // buffer overflow
	char gb_rx_byte;
	char gb_RX_DATA_UART2[gb_RX_BUFFER_SIZE_UART2];

void USART2_IRQHandler(void)
{
	//  GB_UART_TxChar2('k');
	  if((__NVIC_GetActive(USART2_IRQn)) == 1)
    //check if we are here because of RXNE interrupt
         if (USART2->SR & USART_SR_RXNE) //if RX is not empty
                {
                      gb_rx_byte = USART2->DR; //fetch the data received
                      gb_Rx_Buffer_UART2[gb_RX_Wr_Index_UART2]= gb_rx_byte;
  		              if(++gb_RX_Wr_Index_UART2 > gb_RX_BUFFER_SIZE_UART2)
  		              gb_RX_Wr_Index_UART2 = 0;
  		              if(++gb_RX_Counter_UART2 > gb_RX_BUFFER_SIZE_UART2)
  		                   {

  			                    gb_RX_Counter_UART2 = gb_RX_BUFFER_SIZE_UART2;
  			                    gb_RX_Buffer_Overflow_UART2 = 1;
  			                }
  			          gb_RX_No_of_byte_UART2=gb_RX_Counter_UART2 ;

                     // GB_UART_TxChar1(gb_rx_byte);

  			          //printf("%d",gb_rx_byte);

                 }

}

char  GB_getchar_UART2()             // <--->   Serial.read()
{
	char gb_c;
	gb_c = gb_Rx_Buffer_UART2[gb_RX_Rd_Index_UART2];
	if(++gb_RX_Rd_Index_UART2 > gb_RX_BUFFER_SIZE_UART2)
	gb_RX_Rd_Index_UART2 = 0;
	if(gb_RX_Counter_UART2)
	gb_RX_Counter_UART2--;
	GB_UART_TxChar1(gb_c);
	return gb_c ;//return char *
	//printString0("n \n ");
}

void GB_getstring_UART2()
{
	//GB_printString1(" Number of characters received : ");
	//GB_decimel1(gb_RX_No_of_byte_UART2);
	//GB_printString1("\n");
	uint8_t gb_x=0;
	memset(gb_RX_DATA_UART2, '\0',gb_RX_BUFFER_SIZE_UART2);
	while (gb_RX_Counter_UART2)
	{
		gb_RX_DATA_UART2[gb_x]= GB_getchar_UART2();
		gb_x++;
	}
	GB_printString1(gb_RX_DATA_UART2);
	//_delay_ms(1000);

}

int main(void)
{


     system_clk();
	 timer_initialise();

		 //terminal
		GB_uart_init1();
		GB_printString1("STM32 device driver\n");
		GB_printString1("Kunal Gupta\n");
		//ESP8266
		GB_uart_init2();
		__NVIC_EnableIRQ(USART2_IRQn);
		__NVIC_SetPriority (USART2_IRQn, 1);


		GB_printString2("AT+CWMODE?\r\n");
		GB_getstring_UART2();

		GB_printString2("AT+GMR\r\n");
		GB_getstring_UART2();



		GB_printString2("AT+CIPMUX?\r\n");
		GB_getstring_UART2();



    /* Loop forever */
	while(1)
	{

	}
}
